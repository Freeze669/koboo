#!/usr/bin/env python3
# -*- coding: utf-8 -*-
"""
Multi-Language Adapter pour Mayu & Jack Studio
Adaptateur universel pour l'int√©gration entre tous les langages du projet
Permet la communication et le partage de donn√©es entre C++, PHP, CSS, Lua, Python, Rust et Ruby
"""

import json
import subprocess
import os
import sys
import asyncio
import aiofiles
import yaml
from pathlib import Path
from typing import Dict, List, Any, Optional, Union
from dataclasses import dataclass, asdict
from concurrent.futures import ThreadPoolExecutor, as_completed
import logging
from datetime import datetime
import hashlib

# Configuration des logs
logging.basicConfig(
    level=logging.INFO,
    format='%(asctime)s - %(name)s - %(levelname)s - %(message)s'
)
logger = logging.getLogger('MultiLanguageAdapter')

@dataclass
class LanguageInterface:
    """Interface pour d√©finir les capacit√©s d'un langage"""
    name: str
    version: str
    executable: str
    file_extensions: List[str]
    capabilities: List[str]
    data_formats: List[str]  # json, yaml, binary, etc.
    communication_methods: List[str]  # file, pipe, http, socket

@dataclass
class AdapterMessage:
    """Message standardis√© entre les langages"""
    source_language: str
    target_language: str
    message_type: str  # command, data, response, error
    payload: Dict[str, Any]
    timestamp: str
    message_id: str

class MultiLanguageAdapter:
    """Adaptateur principal pour la communication inter-langages"""
    
    def __init__(self, config_path: Optional[str] = None):
        self.config = self._load_config(config_path)
        self.languages = self._initialize_languages()
        self.shared_data = {}
        self.message_queue = asyncio.Queue()
        self.active_processes = {}
        
        # Cr√©er les r√©pertoires de communication
        self._setup_communication_dirs()
        
        logger.info("üåê Multi-Language Adapter initialis√© pour Mayu & Jack Studio")
    
    def _load_config(self, config_path: Optional[str]) -> Dict:
        """Charge la configuration depuis un fichier ou utilise la config par d√©faut"""
        default_config = {
            "shared_data_dir": "shared_data",
            "temp_dir": "temp",
            "communication_timeout": 30,
            "max_concurrent_processes": 8,
            "enable_caching": True,
            "cache_ttl": 3600,
            "log_level": "INFO"
        }
        
        if config_path and os.path.exists(config_path):
            with open(config_path, 'r') as f:
                user_config = yaml.safe_load(f)
                default_config.update(user_config)
        
        return default_config
    
    def _initialize_languages(self) -> Dict[str, LanguageInterface]:
        """Initialise les interfaces pour tous les langages support√©s"""
        return {
            'python': LanguageInterface(
                name='Python',
                version='3.9+',
                executable='python',
                file_extensions=['.py'],
                capabilities=['data_processing', 'image_optimization', 'api_server'],
                data_formats=['json', 'yaml', 'pickle', 'numpy'],
                communication_methods=['file', 'pipe', 'http']
            ),
            
            'cpp': LanguageInterface(
                name='C++',
                version='17',
                executable='g++',
                file_extensions=['.cpp', '.hpp'],
                capabilities=['performance_optimization', 'image_processing', 'algorithms'],
                data_formats=['json', 'binary', 'protobuf'],
                communication_methods=['file', 'pipe', 'shared_memory']
            ),
            
            'php': LanguageInterface(
                name='PHP',
                version='8.0+',
                executable='php',
                file_extensions=['.php'],
                capabilities=['web_backend', 'form_processing', 'database'],
                data_formats=['json', 'xml', 'serialize'],
                communication_methods=['file', 'http', 'database']
            ),
            
            'rust': LanguageInterface(
                name='Rust',
                version='1.70+',
                executable='cargo',
                file_extensions=['.rs'],
                capabilities=['performance_utils', 'concurrency', 'system_programming'],
                data_formats=['json', 'binary', 'messagepack'],
                communication_methods=['file', 'pipe', 'socket']
            ),
            
            'ruby': LanguageInterface(
                name='Ruby',
                version='3.0+',
                executable='ruby',
                file_extensions=['.rb'],
                capabilities=['color_processing', 'automation', 'dsl'],
                data_formats=['json', 'yaml', 'marshal'],
                communication_methods=['file', 'pipe', 'http']
            ),
            
            'javascript': LanguageInterface(
                name='JavaScript',
                version='ES2020',
                executable='node',
                file_extensions=['.js', '.mjs'],
                capabilities=['frontend', 'animation', 'dom_manipulation'],
                data_formats=['json', 'yaml'],
                communication_methods=['file', 'http', 'websocket']
            ),
            
            'lua': LanguageInterface(
                name='Lua',
                version='5.4',
                executable='lua',
                file_extensions=['.lua'],
                capabilities=['configuration', 'scripting', 'embedding'],
                data_formats=['json', 'lua_table'],
                communication_methods=['file', 'pipe']
            )
        }
    
    def _setup_communication_dirs(self):
        """Cr√©e les r√©pertoires de communication"""
        dirs = [
            self.config['shared_data_dir'],
            self.config['temp_dir'],
            'communication/inbox',
            'communication/outbox',
            'communication/logs',
            'cache'
        ]
        
        for dir_path in dirs:
            Path(dir_path).mkdir(parents=True, exist_ok=True)
    
    async def send_message(self, message: AdapterMessage) -> bool:
        """Envoie un message √† un autre langage"""
        try:
            # S√©rialiser le message
            message_data = asdict(message)
            message_file = f"communication/outbox/{message.message_id}_{message.target_language}.json"
            
            async with aiofiles.open(message_file, 'w') as f:
                await f.write(json.dumps(message_data, indent=2))
            
            logger.info(f"üì§ Message envoy√©: {message.source_language} ‚Üí {message.target_language}")
            return True
            
        except Exception as e:
            logger.error(f"‚ùå Erreur envoi message: {e}")
            return False
    
    async def receive_messages(self) -> List[AdapterMessage]:
        """Re√ßoit les messages en attente"""
        messages = []
        inbox_dir = Path('communication/inbox')
        
        try:
            for message_file in inbox_dir.glob('*.json'):
                async with aiofiles.open(message_file, 'r') as f:
                    content = await f.read()
                    message_data = json.loads(content)
                    
                    message = AdapterMessage(**message_data)
                    messages.append(message)
                
                # D√©placer le fichier trait√©
                processed_dir = inbox_dir / 'processed'
                processed_dir.mkdir(exist_ok=True)
                message_file.rename(processed_dir / message_file.name)
            
            if messages:
                logger.info(f"üì• {len(messages)} messages re√ßus")
            
            return messages
            
        except Exception as e:
            logger.error(f"‚ùå Erreur r√©ception messages: {e}")
            return []
    
    async def execute_language_script(self, language: str, script_path: str, 
                                    args: List[str] = None, 
                                    input_data: Dict = None) -> Dict:
        """Ex√©cute un script dans le langage sp√©cifi√©"""
        if language not in self.languages:
            raise ValueError(f"Langage non support√©: {language}")
        
        lang_interface = self.languages[language]
        args = args or []
        
        # Pr√©parer les donn√©es d'entr√©e
        if input_data:
            input_file = f"{self.config['temp_dir']}/input_{language}_{datetime.now().timestamp()}.json"
            async with aiofiles.open(input_file, 'w') as f:
                await f.write(json.dumps(input_data))
            args.extend(['--input', input_file])
        
        # Construire la commande
        if language == 'cpp':
            # Compiler puis ex√©cuter
            executable_name = f"{self.config['temp_dir']}/compiled_{Path(script_path).stem}"
            compile_cmd = [lang_interface.executable, '-std=c++17', '-O3', script_path, '-o', executable_name]
            
            compile_result = await asyncio.create_subprocess_exec(
                *compile_cmd,
                stdout=asyncio.subprocess.PIPE,
                stderr=asyncio.subprocess.PIPE
            )
            await compile_result.wait()
            
            if compile_result.returncode != 0:
                stderr = await compile_result.stderr.read()
                raise RuntimeError(f"Erreur compilation C++: {stderr.decode()}")
            
            cmd = [executable_name] + args
        
        elif language == 'rust':
            # Utiliser cargo run
            cmd = ['cargo', 'run', '--manifest-path', f"{Path(script_path).parent}/Cargo.toml"] + args
        
        else:
            # Langages interpr√©t√©s
            cmd = [lang_interface.executable, script_path] + args
        
        # Ex√©cuter le script
        try:
            process = await asyncio.create_subprocess_exec(
                *cmd,
                stdout=asyncio.subprocess.PIPE,
                stderr=asyncio.subprocess.PIPE,
                cwd=Path(script_path).parent
            )
            
            stdout, stderr = await asyncio.wait_for(
                process.communicate(), 
                timeout=self.config['communication_timeout']
            )
            
            result = {
                'returncode': process.returncode,
                'stdout': stdout.decode('utf-8'),
                'stderr': stderr.decode('utf-8'),
                'success': process.returncode == 0
            }
            
            # Essayer de parser la sortie JSON
            try:
                if result['stdout'].strip():
                    result['data'] = json.loads(result['stdout'])
            except json.JSONDecodeError:
                pass
            
            logger.info(f"üöÄ Script {language} ex√©cut√©: {script_path}")
            return result
            
        except asyncio.TimeoutError:
            logger.error(f"‚è∞ Timeout lors de l'ex√©cution du script {language}")
            return {'success': False, 'error': 'Timeout'}
        
        except Exception as e:
            logger.error(f"‚ùå Erreur ex√©cution {language}: {e}")
            return {'success': False, 'error': str(e)}
    
    async def coordinate_optimization_pipeline(self, image_paths: List[str]) -> Dict:
        """Coordonne un pipeline d'optimisation multi-langages"""
        pipeline_id = hashlib.md5(str(datetime.now()).encode()).hexdigest()[:8]
        results = {}
        
        logger.info(f"üîÑ D√©marrage pipeline d'optimisation {pipeline_id}")
        
        try:
            # 1. Analyse des images avec Python
            python_result = await self.execute_language_script(
                'python',
                'image_optimizer.py',
                ['--analyze'] + image_paths,
                {'pipeline_id': pipeline_id, 'mode': 'analyze'}
            )
            results['python_analysis'] = python_result
            
            # 2. Optimisation performance avec C++
            if python_result['success']:
                cpp_result = await self.execute_language_script(
                    'cpp',
                    'performance_optimizer.cpp',
                    ['--optimize', f"--data={self.config['shared_data_dir']}/analysis_{pipeline_id}.json"]
                )
                results['cpp_optimization'] = cpp_result
            
            # 3. Traitement concurrentiel avec Rust
            rust_result = await self.execute_language_script(
                'rust',
                'performance_utils.rs',
                ['--concurrent-process', f"--input={self.config['shared_data_dir']}/optimized_{pipeline_id}.json"]
            )
            results['rust_processing'] = rust_result
            
            # 4. G√©n√©ration des couleurs avec Ruby
            ruby_result = await self.execute_language_script(
                'ruby',
                'color_animation_engine.rb',
                ['--extract-colors', f"--images={','.join(image_paths)}"]
            )
            results['ruby_colors'] = ruby_result
            
            # 5. Mise √† jour du backend PHP
            if all(r.get('success', False) for r in results.values()):
                php_result = await self.execute_language_script(
                    'php',
                    'backend.php',
                    ['--update-optimized', f"--pipeline={pipeline_id}"]
                )
                results['php_backend'] = php_result
            
            # G√©n√©rer le rapport final
            final_report = {
                'pipeline_id': pipeline_id,
                'timestamp': datetime.now().isoformat(),
                'total_images': len(image_paths),
                'results': results,
                'success': all(r.get('success', False) for r in results.values()),
                'processing_chain': ['Python', 'C++', 'Rust', 'Ruby', 'PHP']
            }
            
            # Sauvegarder le rapport
            report_file = f"{self.config['shared_data_dir']}/pipeline_report_{pipeline_id}.json"
            async with aiofiles.open(report_file, 'w') as f:
                await f.write(json.dumps(final_report, indent=2))
            
            logger.info(f"‚úÖ Pipeline {pipeline_id} termin√© avec succ√®s")
            return final_report
            
        except Exception as e:
            logger.error(f"‚ùå Erreur pipeline {pipeline_id}: {e}")
            return {
                'pipeline_id': pipeline_id,
                'success': False,
                'error': str(e),
                'results': results
            }
    
    async def create_unified_color_system(self) -> Dict:
        """Cr√©e un syst√®me de couleurs unifi√© √† travers tous les langages"""
        logger.info("üé® Cr√©ation du syst√®me de couleurs unifi√©")
        
        # 1. G√©n√©rer la palette ma√Ætre avec Ruby
        ruby_result = await self.execute_language_script(
            'ruby',
            'color_animation_engine.rb',
            ['--generate-master-palette']
        )
        
        if not ruby_result.get('success'):
            return {'success': False, 'error': '√âchec g√©n√©ration palette Ruby'}
        
        master_palette = ruby_result.get('data', {})
        
        # 2. Optimiser les couleurs pour les performances avec Rust
        rust_result = await self.execute_language_script(
            'rust',
            'performance_utils.rs',
            ['--optimize-colors'],
            {'palette': master_palette}
        )
        
        # 3. G√©n√©rer les adaptateurs pour chaque langage
        adaptations = {}
        
        # CSS avanc√©
        css_content = await self._generate_css_from_palette(master_palette)
        css_file = 'mayu_jack_unified_colors.css'
        async with aiofiles.open(css_file, 'w') as f:
            await f.write(css_content)
        adaptations['css'] = css_file
        
        # JavaScript
        js_content = await self._generate_js_from_palette(master_palette)
        js_file = 'mayu_jack_colors.js'
        async with aiofiles.open(js_file, 'w') as f:
            await f.write(js_content)
        adaptations['javascript'] = js_file
        
        # PHP
        php_content = await self._generate_php_from_palette(master_palette)
        php_file = 'mayu_jack_colors.php'
        async with aiofiles.open(php_file, 'w') as f:
            await f.write(php_content)
        adaptations['php'] = php_file
        
        # Lua configuration
        lua_content = await self._generate_lua_from_palette(master_palette)
        lua_file = 'color_config.lua'
        async with aiofiles.open(lua_file, 'w') as f:
            await f.write(lua_content)
        adaptations['lua'] = lua_file
        
        # C++ header
        cpp_content = await self._generate_cpp_from_palette(master_palette)
        cpp_file = 'mayu_jack_colors.hpp'
        async with aiofiles.open(cpp_file, 'w') as f:
            await f.write(cpp_content)
        adaptations['cpp'] = cpp_file
        
        unified_system = {
            'master_palette': master_palette,
            'optimizations': rust_result.get('data', {}),
            'adaptations': adaptations,
            'created_at': datetime.now().isoformat(),
            'version': '1.0.0'
        }
        
        # Sauvegarder le syst√®me unifi√©
        system_file = 'unified_color_system.json'
        async with aiofiles.open(system_file, 'w') as f:
            await f.write(json.dumps(unified_system, indent=2))
        
        logger.info("‚úÖ Syst√®me de couleurs unifi√© cr√©√© avec succ√®s")
        return unified_system
    
    async def _generate_css_from_palette(self, palette: Dict) -> str:
        """G√©n√®re du CSS avanc√© √† partir de la palette"""
        css = """/* Syst√®me de couleurs unifi√© - Mayu & Jack Studio */\n:root {\n"""
        
        # Variables CSS
        for category, colors in palette.items():
            if isinstance(colors, dict):
                for name, color in colors.items():
                    css += f"  --{category}-{name}: {color};\n"
            elif isinstance(colors, list):
                for i, color in enumerate(colors):
                    css += f"  --{category}-{i}: {color};\n"
        
        css += "}\n\n"
        
        # Classes utilitaires
        css += "/* Classes utilitaires */\n"
        for category in palette.keys():
            if isinstance(palette[category], dict):
                for name in palette[category].keys():
                    safe_name = name.replace('_', '-')
                    css += f".text-{category}-{safe_name} {{ color: var(--{category}-{name}); }}\n"
                    css += f".bg-{category}-{safe_name} {{ background-color: var(--{category}-{name}); }}\n"
        
        return css
    
    async def _generate_js_from_palette(self, palette: Dict) -> str:
        """G√©n√®re du JavaScript √† partir de la palette"""
        js = f"""// Syst√®me de couleurs unifi√© - Mayu & Jack Studio
const MayuJackColors = {json.dumps(palette, indent=2)};

// Utilitaires
MayuJackColors.utils = {{
  applyColor(element, color, property = 'color') {{
    if (typeof element === 'string') {{
      element = document.querySelector(element);
    }}
    if (element) {{
      element.style[property] = color;
    }}
  }},
  
  createGradient(colors, direction = '45deg') {{
    return `linear-gradient(${{direction}}, ${{colors.join(', ')}})`;
  }},
  
  getColorByPath(path) {{
    return path.split('.').reduce((obj, key) => obj?.[key], this);
  }}
}};

export default MayuJackColors;
"""
        return js
    
    async def _generate_php_from_palette(self, palette: Dict) -> str:
        """G√©n√®re du PHP √† partir de la palette"""
        php = f"""<?php
/**
 * Syst√®me de couleurs unifi√© - Mayu & Jack Studio
 */
class MayuJackColors {{
    const PALETTE = {json.dumps(palette).replace('true', 'true').replace('false', 'false')};
    
    public static function getColor(string $path): ?string {{
        $keys = explode('.', $path);
        $current = self::PALETTE;
        
        foreach ($keys as $key) {{
            if (!isset($current[$key])) {{
                return null;
            }}
            $current = $current[$key];
        }}
        
        return is_string($current) ? $current : null;
    }}
    
    public static function generateCSS(): string {{
        $css = '';
        // Implementation CSS generation
        return $css;
    }}
}}
?>"""
        return php
    
    async def _generate_lua_from_palette(self, palette: Dict) -> str:
        """G√©n√®re du Lua √† partir de la palette"""
        def dict_to_lua(d, indent=0):
            lines = []
            spacing = "  " * indent
            for key, value in d.items():
                if isinstance(value, dict):
                    lines.append(f"{spacing}{key} = {{")
                    lines.append(dict_to_lua(value, indent + 1))
                    lines.append(f"{spacing}}},")
                elif isinstance(value, list):
                    lines.append(f"{spacing}{key} = {{")
                    for item in value:
                        lines.append(f"{spacing}  \"{item}\",")
                    lines.append(f"{spacing}}},")
                else:
                    lines.append(f"{spacing}{key} = \"{value}\",")
            return "\n".join(lines)
        
        lua = f"""-- Syst√®me de couleurs unifi√© - Mayu & Jack Studio
local MayuJackColors = {{
{dict_to_lua(palette, 1)}
}}

return MayuJackColors"""
        return lua
    
    async def _generate_cpp_from_palette(self, palette: Dict) -> str:
        """G√©n√®re du C++ header √† partir de la palette"""
        cpp = """#pragma once
#include <string>
#include <unordered_map>

namespace MayuJackStudio {
    class Colors {
    public:
        static const std::unordered_map<std::string, std::string> PALETTE;
        static std::string getColor(const std::string& name);
    };
}
"""
        return cpp
    
    def get_statistics(self) -> Dict:
        """Retourne les statistiques de l'adaptateur"""
        return {
            'supported_languages': len(self.languages),
            'active_processes': len(self.active_processes),
            'shared_data_size': self._get_shared_data_size(),
            'cache_size': self._get_cache_size(),
            'uptime': datetime.now().isoformat()
        }
    
    def _get_shared_data_size(self) -> int:
        """Calcule la taille des donn√©es partag√©es"""
        total_size = 0
        shared_dir = Path(self.config['shared_data_dir'])
        if shared_dir.exists():
            for file_path in shared_dir.rglob('*'):
                if file_path.is_file():
                    total_size += file_path.stat().st_size
        return total_size
    
    def _get_cache_size(self) -> int:
        """Calcule la taille du cache"""
        total_size = 0
        cache_dir = Path('cache')
        if cache_dir.exists():
            for file_path in cache_dir.rglob('*'):
                if file_path.is_file():
                    total_size += file_path.stat().st_size
        return total_size

# Interface en ligne de commande
async def main():
    """Point d'entr√©e principal"""
    import argparse
    
    parser = argparse.ArgumentParser(description="Multi-Language Adapter - Mayu & Jack Studio")
    parser.add_argument('--action', choices=['pipeline', 'colors', 'test', 'stats'], 
                       default='test', help='Action √† ex√©cuter')
    parser.add_argument('--images', nargs='*', help='Chemins des images pour le pipeline')
    parser.add_argument('--config', help='Fichier de configuration')
    
    args = parser.parse_args()
    
    # Initialiser l'adaptateur
    adapter = MultiLanguageAdapter(args.config)
    
    print("üåê Multi-Language Adapter - Mayu & Jack Studio")
    print("=" * 50)
    
    if args.action == 'pipeline':
        if not args.images:
            print("‚ùå Images requises pour le pipeline")
            return
        
        result = await adapter.coordinate_optimization_pipeline(args.images)
        print(f"üìä Pipeline termin√©: {result['success']}")
        print(f"üìÅ Rapport: {result.get('pipeline_id', 'N/A')}")
    
    elif args.action == 'colors':
        result = await adapter.create_unified_color_system()
        print(f"üé® Syst√®me de couleurs cr√©√©: {result.get('version', 'N/A')}")
        print(f"üìÑ Adaptations: {len(result.get('adaptations', {}))}")
    
    elif args.action == 'stats':
        stats = adapter.get_statistics()
        print("üìä Statistiques:")
        for key, value in stats.items():
            print(f"   ‚Ä¢ {key}: {value}")
    
    else:  # test
        print("üß™ Test de communication inter-langages...")
        
        # Test simple avec Python
        python_test = await adapter.execute_language_script(
            'python',
            '-c',
            ['print({"status": "ok", "message": "Python communication test"})']
        )
        
        print(f"‚úÖ Test Python: {'‚úì' if python_test['success'] else '‚úó'}")
        
        # Statistiques finales
        stats = adapter.get_statistics()
        print(f"\nüìä Langages support√©s: {stats['supported_languages']}")
        print(f"üíæ Donn√©es partag√©es: {stats['shared_data_size']} octets")

if __name__ == '__main__':
    asyncio.run(main())
